<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="light dark" />
    <title>Segment tree</title>

    <link rel="preload stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown-dark.min.css" />
    <link rel="preload stylesheet" href="https://cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css" />
    <link rel="preload stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
        integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous" />
    <link rel="preload stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" />
    <link rel="stylesheet" href="./style/style.css" />

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.25.0/tocbot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"
        integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"
        defer></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
        onload="renderMathInElement(document.body);" defer></script>
    <script src="./js/index.js" type="text/javascript" defer></script>
</head>

<body>
    <main class="markdown-body">
        <aside><div class="toc" id="outline"></div></aside>
        <article id="doc">
            <article>
                <h1>Segment tree</h1>
                <div class="toc"></div>
                <article>
                    <h2>Fundamental of Segment Tree</h2>
                    <article>
                        <h3>Concept</h3>
                        <section class="problem" id="bài-toán-1">
                            <h4 class="problem-title">Bài toán 1</h4>
                            <section class="problem-detail">
                                <p>Cho mảng \(A\) có \(n\) phần tử. Tìm \(min(A)\)</p>
                            </section>
                            <details class="solution">
                                <summary class="solution-complete">Solution</summary>
                                <div class="content">
                                    <p> Duyệt qua toàn bộ mảng và tìm </p>
                                    <pre><code class="hljs cpp">int solve(int n)
{
    int result = INT_MAX;

    for (int i = 0; i &lt; n; i++)
    {
        int temp;
        cin &gt;&gt; temp;
        result = min(result, temp);
    }

    return result;
}</code></pre>
                                    <ul>
                                        <li>Time complexity: \(O(n)\)</li>
                                        <li>Space complexity: \(O(1)\)</li>
                                    </ul>
                                </div>
                            </details>
                        </section>
                        <section class="problem" id="bài-toán-2">
                            <h4 class="problem-title">Bài toán 2</h4>
                            <section class="problem-detail">
                                <p>
                                    Cho mảng \( A \) có \(n\) phần tử. Cho \(q\) truy vấn. Mỗi truy vấn có dạng:<br>
                                <ul>
                                    <li><mark>\(p\ x\)</mark>: Update phần tử tại \(p\) thành \(x\). Tính \(min(A)\)
                                    </li>
                                </ul>
                                </p>
                            </section>
                            <details class="solution">
                                <summary class="solution-fail">Bruteforce</summary>
                                <div class="content">
                                    <p> Như <a href="#bài-toán-1">bài toán 1</a>, duyệt toàn bộ mảng và tính lại mỗi
                                        query
                                    </p>
                                    <pre><code class="hljs cpp">void solve(int n)
{
    for (int i = 0; i &lt; q; i++)
    {
        int p, x, result = INT_MAX;
        cin &gt;&gt; p &gt;&gt; x;
        A[p] = x;

        for (int j = 0; j &lt; n; j++)
        {
            result = min(result, A[j]);
        }

        cout &lt;&lt; result &lt;&lt; "\n";
    }
    return 0;
}</code></pre>
                                    <ul>
                                        <li>Time complexity: <span class="solution-fail">\(O(n \times q)\)</span></li>
                                        <li>Space complexity: \(O(n)\)</li>
                                    </ul>
                                </div>
                            </details>
                            <details class="solution">
                                <summary class="solution-partial">Optimize #1</summary>
                                <div class="content">
                                    <p> Chia đôi mảng. Sau đó tìm \(min\) của 2 nửa. Với mỗi query, xác định \(p\) thuộc
                                        phần
                                        nào của 2 nửa và tính lại phần đó.</p>
                                    <pre><code class="hljs cpp">vector&lt;int&gt; min_val(2, INT_MAX);

void preprocess()
{
    for (int i = 0; i &lt; A.size(); i++)
    {
        min_val[i &gt;= (A.size() / 2)] = min(min_val[i &gt;= (A.size() / 2)], A[i]);
    }
}

void solve(int q)
{
    preprocess();

    for (int i = 0; i &lt; q; i++)
    {
        int p, x;
        cin &gt;&gt; p &gt;&gt; x;
        A[p] = x;

        if (p &lt; (A.size() / 2))
        {
            for (int j = 0; j &lt; A.size() / 2; j++)
            {
                min_val[0] = min(min_val[0], A[j]);
            }
        }
        else
        {
            for (int j = A.size() / 2; j &lt; A.size(); j++)
            {
                min_val[1] = min(min_val[1], A[j]);
            }
        }

        cout &lt;&lt; min(min_val[0], min_val[1]) &lt;&lt; &quot;\n&quot;;
    }
}</code></pre>
                                    <ul>
                                        <li>Time complexity: <span class="solution-partial">\(O(\frac{n}{2} \times
                                                q)\)</span>
                                        </li>
                                        <li>Space complexity: \(O(n)\)</li>
                                    </ul>
                                </div>
                            </details>
                        </section>
                    </article>
                    <article>
                        <h3>Walk on tree</h3>
                    </article>
                    <article>
                        <h3>Lazy propagation</h3>
                    </article>
                </article>
                <article>
                    <h2>Application</h2>
                    <article>
                        <h3>Obvious range query</h3>
                    </article>
                    <article>
                        <h3>Algorithm optimization</h3>
                    </article>
                    <article>
                        <h3>Multiple segment trees</h3>
                    </article>
                    <article>
                        <h3>Graph</h3>
                    </article>
                    <article>
                        <h3>Data structure</h3>
                    </article>
                </article>
            </article>
        </article>
    </main>
</body>

</html>