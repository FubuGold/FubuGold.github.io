<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="light dark" />
    <title>Segment tree</title>

    <link rel="preload stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown-dark.min.css" />
    <link rel="preload stylesheet" href="https://cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css" />
    <link rel="preload stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
        integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous" />
    <link rel="preload stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" />
    <link rel="stylesheet" href="./style/style.css" />

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.25.0/tocbot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"
        integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"
        defer></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
        onload="renderMathInElement(document.body);" defer></script>
    <script src="./js/index.js" type="text/javascript" defer></script>
</head>

<body>
    <main class="markdown-body">
        <aside><div class="toc" id="outline"></div></aside>
        <article id="doc">
            <article>
                <h1>Segment tree</h1>
                <div class="toc"></div>
                <article>
                    <h2>Fundamental of Segment Tree</h2>
                    <article>
                        <h3>Concept</h3>
                        <section class="problem" id="bài-toán-1">
                            <h4 class="problem-title">Bài toán 1</h4>
                            <section class="problem-detail">
                                <p>Cho mảng \(A\) có \(n\) phần tử. Tìm \(min(A)\)</p>
                            </section>
                            <details class="solution">
                                <summary class="solution-complete">Solution</summary>
                                <div class="content">
                                    <p> Duyệt qua toàn bộ mảng và tìm </p>
                                    <pre><code class="hljs cpp">int solve(int n)
{
    int result = INT_MAX;

    for (int i = 0; i &lt; n; i++)
    {
        int temp;
        cin &gt;&gt; temp;
        result = min(result, temp);
    }

    return result;
}</code></pre>
                                    <ul>
                                        <li>Time complexity: \(O(n)\)</li>
                                        <li>Space complexity: \(O(1)\)</li>
                                    </ul>
                                </div>
                            </details>
                        </section>
                        <section class="problem" id="bài-toán-2">
                            <h4 class="problem-title">Bài toán 2</h4>
                            <section class="problem-detail">
                                <p>
                                    Cho mảng \( A \) có \(n\) phần tử. Cho \(q\) truy vấn. Mỗi truy vấn có dạng:<br>
                                <ul>
                                    <li><mark>\(p\ x\)</mark>: Update phần tử tại \(p\) thành \(x\). Tính \(min(A)\)
                                    </li>
                                </ul>
                                </p>
                            </section>
                            <details class="solution">
                                <summary class="solution-fail">Bruteforce</summary>
                                <div class="content">
                                    <p> Như <a href="#bài-toán-1">bài toán 1</a>, duyệt toàn bộ mảng và tính lại mỗi
                                        query
                                    </p>
                                    <pre><code class="hljs cpp">void solve(int n)
{
    for (int i = 0; i &lt; q; i++)
    {
        int p, x, result = INT_MAX;
        cin &gt;&gt; p &gt;&gt; x;
        A[p] = x;

        for (int j = 0; j &lt; n; j++)
        {
            result = min(result, A[j]);
        }

        cout &lt;&lt; result &lt;&lt; "\n";
    }
    return 0;
}</code></pre>
                                    <ul>
                                        <li>Time complexity: <span class="solution-fail">\(O(n \times q)\)</span></li>
                                        <li>Space complexity: \(O(n)\)</li>
                                    </ul>
                                </div>
                            </details>
                            <details class="solution">
                                <summary class="solution-partial">Optimize #1</summary>
                                <div class="content">
                                    <p> Chia đôi mảng. Sau đó tìm \(min\) của 2 nửa. Với mỗi query, xác định \(p\) thuộc
                                        phần
                                        nào của 2 nửa và tính lại phần đó.</p>
                                    <pre><code class="hljs cpp">vector&lt;int&gt; min_val(2, INT_MAX);

void preprocess()
{
    for (int i = 0; i &lt; A.size(); i++)
    {
        min_val[i &gt;= (A.size() / 2)] = min(min_val[i &gt;= (A.size() / 2)], A[i]);
    }
}

void solve(int q)
{
    preprocess();

    for (int i = 0; i &lt; q; i++)
    {
        int p, x;
        cin &gt;&gt; p &gt;&gt; x;
        A[p] = x;

        if (p &lt; (A.size() / 2))
        {
            for (int j = 0; j &lt; A.size() / 2; j++)
            {
                min_val[0] = min(min_val[0], A[j]);
            }
        }
        else
        {
            for (int j = A.size() / 2; j &lt; A.size(); j++)
            {
                min_val[1] = min(min_val[1], A[j]);
            }
        }

        cout &lt;&lt; min(min_val[0], min_val[1]) &lt;&lt; &quot;\n&quot;;
    }
}</code></pre>
                                    <ul>
                                        <li>Time complexity: <span class="solution-partial">\(O(\frac{n}{2} \times
                                                q)\)</span>
                                        </li>
                                        <li>Space complexity: \(O(n)\)</li>
                                    </ul>
                                </div>
                            </details>
                        </section>
                    </article>
                    <article>
                        <h3>Walk on tree</h3>
                    </article>
                    <article>
                        <h3>Lazy propagation</h3>
                    </article>
                </article>
                <article>
                    <h2>Application</h2>
                    <article>
                        <h3>Obvious range query</h3>
                        <p>
                            Đây là những bài toán mà việc truy vấn được nêu rõ trực tiếp trong đề hoặc rất dễ để nhận ra.
                            Thường các bài toán dạng này sẽ thêm một số điều kiện, trạng thái để lưu trên Segment tree. <br>
                            <section class="problem" id="obvious-range-query">
                                <h4 class="problem-title">Bài toán ví dụ:</h4>
                                <section class="problem-detail">
                                    <p>
                                        Cho mảng \( A \) gồm \( 2^n \) phần tử không âm. Tìm giá trị \( v \) từ mảng A bằng cách sau:
                                        <ul>
                                            <li>Từ mảng A tạo mảng mới gồm \( A_1 or A_2, A_3 or A_4, ..., A_{2^n-1} or A_{2^n} \) có \( 2^{n-1} \) phần tử. Nói cách khác là tạo mảng mới từ giá trị của phép tính \( or \) giữa hai phần tử liên tiếp</li>
                                            <li>Từ mảng trên tạo mảng mới từ giá trị của phép tính \( xor \) giữa hai phần tử liên tiếp</li>
                                            <li>Lặp lại cho đến khi còn 1 phần tử. Phần tử đó là \( v \) cần tìm</li>
                                        </ul>
                                        Cho \( m \) truy vấn như sau: 
                                        <ul>
                                            <li><mark>\( p\  x \)</mark>: Update phần tử tại \( p \) thành \( x \). Tìm và in ra giá trị \( v \).</li>
                                        </ul>
                                        Giới hạn:
                                        <ul>
                                            <li>\( n &le; 17 \)</li>
                                        </ul>
                                    </p>
                                </section>
                                <details class="solution">
                                    <summary class="solution-complete">Solution</summary>
                                    <div class="content">
                                        <p>
                                            Đây là dạng bài cập nhập trên điểm và truy vấn trên đoạn nên chúng ta sẽ dùng Segment tree bình thường nhưng có thay đổi nhẹ.
                                            Ta có các nhận xét sau:
                                            <ul>
                                                <li>Vì số lượng phần tử là lũy thừa của 2 nên ST sẽ là <b>cây nhị phân hoàn hảo</b></li>
                                                <li>Việc tạo mảng mới tương tương với việc đi lên một tầng trên ST</li>
                                            </ul>
                                            Từ nhận xét trên, ta có lời giải như sau:
                                            Xây dụng ST trên mảng \( A \) với mỗi node \( u \) trên cây được tính từ node bên trái \( v \) và node bên phải \( t \) bằng phép tính \( or \) hoặc \( xor \) tùy theo tầng của node \( u \).
                                        </p>
                                    </div>
                                </details>
                            </section>
                        </p>
                    </article>
                    <article>
                        <h3>Algorithm optimization</h3>
                    </article>
                    <article>
                        <h3>Multiple segment trees</h3>
                    </article>
                    <article>
                        <h3>Graph</h3>
                    </article>
                    <article>
                        <h3>Data structure</h3>
                    </article>
                </article>
            </article>
        </article>
    </main>
</body>

</html>